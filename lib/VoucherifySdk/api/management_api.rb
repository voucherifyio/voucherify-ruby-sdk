=begin
#Voucherify API

#Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.

The version of the OpenAPI document: v2018-08-01
Contact: support@voucherify.io
Generated by: https://openapi-generator.tech
OpenAPI Generator version: 7.0.1

=end

require 'cgi'

module VoucherifySdk
  class ManagementApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Assign User
    # Assigns a user to a given project. The user must be an existing user in Voucherify.  ðŸš§ Correct Use of Data To avoid errors, use the role key with either id or login keys.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsUsersAssignRequestBody] :management_projects_users_assign_request_body Defines the user details.
    # @return [ManagementProjectsUsersAssignResponseBody]
    def assign_user(project_id, opts = {})
      data, _status_code, _headers = assign_user_with_http_info(project_id, opts)
      data
    end

    # Assign User
    # Assigns a user to a given project. The user must be an existing user in Voucherify.  ðŸš§ Correct Use of Data To avoid errors, use the role key with either id or login keys.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsUsersAssignRequestBody] :management_projects_users_assign_request_body Defines the user details.
    # @return [Array<(ManagementProjectsUsersAssignResponseBody, Integer, Hash)>] ManagementProjectsUsersAssignResponseBody data, response status code and response headers
    private def assign_user_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.assign_user ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/users'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_users_assign_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsUsersAssignResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.assign_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#assign_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Brand
    # Creates a new brand configuration. You can have only one brand configured for a project.  ðŸ“˜ White Labelling  The white labelling settings which can be found in Project Settings > Brand Details and which are available only for Enterprise clients as a separate service can be configured only in the user interface.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsBrandingCreateRequestBody] :management_projects_branding_create_request_body Defines a brand configuration.
    # @return [ManagementProjectsBrandingCreateResponseBody]
    def create_brand(project_id, opts = {})
      data, _status_code, _headers = create_brand_with_http_info(project_id, opts)
      data
    end

    # Create Brand
    # Creates a new brand configuration. You can have only one brand configured for a project.  ðŸ“˜ White Labelling  The white labelling settings which can be found in Project Settings &gt; Brand Details and which are available only for Enterprise clients as a separate service can be configured only in the user interface.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsBrandingCreateRequestBody] :management_projects_branding_create_request_body Defines a brand configuration.
    # @return [Array<(ManagementProjectsBrandingCreateResponseBody, Integer, Hash)>] ManagementProjectsBrandingCreateResponseBody data, response status code and response headers
    private def create_brand_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.create_brand ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/branding'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_branding_create_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsBrandingCreateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.create_brand",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#create_brand\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Custom Event Schema
    # Creates a custom event schema. The properties object is required, but it can be empty, however. This object is for optional custom properties (metadata).  ðŸ“˜ Custom Event Documentation  Read [Custom Events](https://support.voucherify.io/article/111-custom-events) article to learn how custom events work in Voucherify. Read also the details about the Track Custom Event endpoint and the Custom Event Object.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsCustomEventSchemasCreateRequestBody] :management_projects_custom_event_schemas_create_request_body Defines the custom event schema.
    # @return [ManagementProjectsCustomEventSchemasCreateResponseBody]
    def create_custom_event_schema(project_id, opts = {})
      data, _status_code, _headers = create_custom_event_schema_with_http_info(project_id, opts)
      data
    end

    # Create Custom Event Schema
    # Creates a custom event schema. The properties object is required, but it can be empty, however. This object is for optional custom properties (metadata).  ðŸ“˜ Custom Event Documentation  Read [Custom Events](https://support.voucherify.io/article/111-custom-events) article to learn how custom events work in Voucherify. Read also the details about the Track Custom Event endpoint and the Custom Event Object.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsCustomEventSchemasCreateRequestBody] :management_projects_custom_event_schemas_create_request_body Defines the custom event schema.
    # @return [Array<(ManagementProjectsCustomEventSchemasCreateResponseBody, Integer, Hash)>] ManagementProjectsCustomEventSchemasCreateResponseBody data, response status code and response headers
    private def create_custom_event_schema_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.create_custom_event_schema ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/custom-event-schemas'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_custom_event_schemas_create_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsCustomEventSchemasCreateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.create_custom_event_schema",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#create_custom_event_schema\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Metadata Schema
    # Creates a new metadata (custom attribute) schema. The schema consists of a set of key-value pairs to customize Voucherify resources.  You can nest your object within a standard metadata schema, e.g. within a campaign or customer schema. However, your nested object cannot include another nested object. The standard metadata schemas are: - Campaign - Voucher - Publication - Redemption - Product - Customer - Order - Order line item - Loyalty Tier - Promotion Tier - Earning rule - Reward  ðŸ“˜ Metadata Documentation  Read the Getting Started with Metadata articles to learn how metadata work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsMetadataSchemasCreateRequestBody] :management_projects_metadata_schemas_create_request_body Defines the metadata schema.
    # @return [ManagementProjectsMetadataSchemasCreateResponseBody]
    def create_metadata_schema(project_id, opts = {})
      data, _status_code, _headers = create_metadata_schema_with_http_info(project_id, opts)
      data
    end

    # Create Metadata Schema
    # Creates a new metadata (custom attribute) schema. The schema consists of a set of key-value pairs to customize Voucherify resources.  You can nest your object within a standard metadata schema, e.g. within a campaign or customer schema. However, your nested object cannot include another nested object. The standard metadata schemas are: - Campaign - Voucher - Publication - Redemption - Product - Customer - Order - Order line item - Loyalty Tier - Promotion Tier - Earning rule - Reward  ðŸ“˜ Metadata Documentation  Read the Getting Started with Metadata articles to learn how metadata work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsMetadataSchemasCreateRequestBody] :management_projects_metadata_schemas_create_request_body Defines the metadata schema.
    # @return [Array<(ManagementProjectsMetadataSchemasCreateResponseBody, Integer, Hash)>] ManagementProjectsMetadataSchemasCreateResponseBody data, response status code and response headers
    private def create_metadata_schema_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.create_metadata_schema ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/metadata-schemas'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_metadata_schemas_create_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsMetadataSchemasCreateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.create_metadata_schema",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#create_metadata_schema\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Project
    # Creates a new project. You can add users, specify the cluster, timezone, currency, and other details. All owners are added to the project by default.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsCreateRequestBody] :management_projects_create_request_body Define project details.
    # @return [ManagementProjectsCreateResponseBody]
    def create_project(opts = {})
      data, _status_code, _headers = create_project_with_http_info(opts)
      data
    end

    # Create Project
    # Creates a new project. You can add users, specify the cluster, timezone, currency, and other details. All owners are added to the project by default.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsCreateRequestBody] :management_projects_create_request_body Define project details.
    # @return [Array<(ManagementProjectsCreateResponseBody, Integer, Hash)>] ManagementProjectsCreateResponseBody data, response status code and response headers
    private def create_project_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.create_project ...'
      end
      # resource path
      local_var_path = '/management/v1/projects'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_create_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsCreateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.create_project",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#create_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Stacking Rules
    # Overwrites the default stacking rules. If new stacking rules have been created for the project earlier (e.g. in the user interface), it returns an error. Use Update Stacking Rules endpoint to change the rules.  ðŸ“˜ Stacking Rules Documentation  Read [the Stacking Rules article](https://support.voucherify.io/article/604-stacking-rules) to learn how they work.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsStackingRulesCreateRequestBody] :management_projects_stacking_rules_create_request_body Defines the stacking rule parameters.
    # @return [ManagementProjectsStackingRulesCreateResponseBody]
    def create_stacking_rules(project_id, opts = {})
      data, _status_code, _headers = create_stacking_rules_with_http_info(project_id, opts)
      data
    end

    # Create Stacking Rules
    # Overwrites the default stacking rules. If new stacking rules have been created for the project earlier (e.g. in the user interface), it returns an error. Use Update Stacking Rules endpoint to change the rules.  ðŸ“˜ Stacking Rules Documentation  Read [the Stacking Rules article](https://support.voucherify.io/article/604-stacking-rules) to learn how they work.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsStackingRulesCreateRequestBody] :management_projects_stacking_rules_create_request_body Defines the stacking rule parameters.
    # @return [Array<(ManagementProjectsStackingRulesCreateResponseBody, Integer, Hash)>] ManagementProjectsStackingRulesCreateResponseBody data, response status code and response headers
    private def create_stacking_rules_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.create_stacking_rules ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/stacking-rules'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_stacking_rules_create_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsStackingRulesCreateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.create_stacking_rules",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#create_stacking_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create Webhook
    # Creates a new webhook configuration.  ðŸ“˜ Webhook Documentation  Read Webhooks v2024-01-01 article to learn how webhooks work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsWebhooksCreateRequestBody] :management_projects_webhooks_create_request_body Defines a webhook configuration.
    # @return [ManagementProjectsWebhooksCreateResponseBody]
    def create_webhook(project_id, opts = {})
      data, _status_code, _headers = create_webhook_with_http_info(project_id, opts)
      data
    end

    # Create Webhook
    # Creates a new webhook configuration.  ðŸ“˜ Webhook Documentation  Read Webhooks v2024-01-01 article to learn how webhooks work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsWebhooksCreateRequestBody] :management_projects_webhooks_create_request_body Defines a webhook configuration.
    # @return [Array<(ManagementProjectsWebhooksCreateResponseBody, Integer, Hash)>] ManagementProjectsWebhooksCreateResponseBody data, response status code and response headers
    private def create_webhook_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.create_webhook ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/webhooks'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_webhooks_create_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsWebhooksCreateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.create_webhook",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#create_webhook\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Brand
    # Deletes permanently a brand configuration.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param branding_id [String] Provide the unique identifier of the brand configuration.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_brand(project_id, branding_id, opts = {})
      delete_brand_with_http_info(project_id, branding_id, opts)
      nil
    end

    # Delete Brand
    # Deletes permanently a brand configuration.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param branding_id [String] Provide the unique identifier of the brand configuration.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    private def delete_brand_with_http_info(project_id, branding_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.delete_brand ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/branding/{brandingId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'brandingId' + '}', CGI.escape(branding_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.delete_brand",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#delete_brand\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Custom Event Schema
    # Deletes permanently the custom event schema with its custom properties (metadata).  ðŸ“˜ Custom Event Documentation  Read [Custom Events](https://support.voucherify.io/article/111-custom-events) article to learn how custom events work in Voucherify. Read also the details about the Track Custom Event endpoint and the Custom Event Object.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param custom_event_schema_id [String] Provide the unique identifier of the custom event schema.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_custom_event_schema(project_id, custom_event_schema_id, opts = {})
      delete_custom_event_schema_with_http_info(project_id, custom_event_schema_id, opts)
      nil
    end

    # Delete Custom Event Schema
    # Deletes permanently the custom event schema with its custom properties (metadata).  ðŸ“˜ Custom Event Documentation  Read [Custom Events](https://support.voucherify.io/article/111-custom-events) article to learn how custom events work in Voucherify. Read also the details about the Track Custom Event endpoint and the Custom Event Object.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param custom_event_schema_id [String] Provide the unique identifier of the custom event schema.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    private def delete_custom_event_schema_with_http_info(project_id, custom_event_schema_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.delete_custom_event_schema ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/custom-event-schemas/{customEventSchemaId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'customEventSchemaId' + '}', CGI.escape(custom_event_schema_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.delete_custom_event_schema",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#delete_custom_event_schema\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Metadata Schema
    # Deletes permanently the metadata schema. In standard metadata schemas, this endpoint removes permanently all definitions. The standard metadata schemas are: - Campaign - Voucher - Publication - Redemption - Product - Customer - Order - Order line item - Loyalty Tier - Promotion Tier - Earning rule - Reward If you want to delete only one definition, use the Update Metadata Schema endpoint. In the request, provide the deleted: true pair in the definition object. This definition will be moved to Removed definitions. If you want to create a new standard metadata schema, use the Create Metadata Schema endpoint.  ðŸš§ Metadata Purging This endpoint deletes permanently the metadata schemas only. However, it does not purge the metadata from associated entities, so the metadata added to those entities will remain. If you want to purge metadata from the entities: 1. Remove all the definitions you want to purge. You can do this either in Voucherify Project Settings > Metadata Schema tab or with the Update Metadata Schema endpoint. 2. In Voucherify Project Settings > Metadata Schema tab, go to the relevant metadata schema. 3. In Removed definitions, click the bin button next to the definitions whose metadata you want to purge from entities. Note: - This is an asynchronous action. You will be notified when it has been completed. - You cannot purge metadata for the Redemption and Publication schemas. 4. Use the Delete Metadata Schema request to delete the metadata schema from Voucherify.  ðŸ“˜ Metadata Documentation  Read the Getting Started with Metadata articles to learn how metadata work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param metadata_schema_id [String] Provide the unique identifier of the metadata schema.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_metadata_schema(project_id, metadata_schema_id, opts = {})
      delete_metadata_schema_with_http_info(project_id, metadata_schema_id, opts)
      nil
    end

    # Delete Metadata Schema
    # Deletes permanently the metadata schema. In standard metadata schemas, this endpoint removes permanently all definitions. The standard metadata schemas are: - Campaign - Voucher - Publication - Redemption - Product - Customer - Order - Order line item - Loyalty Tier - Promotion Tier - Earning rule - Reward If you want to delete only one definition, use the Update Metadata Schema endpoint. In the request, provide the deleted: true pair in the definition object. This definition will be moved to Removed definitions. If you want to create a new standard metadata schema, use the Create Metadata Schema endpoint.  ðŸš§ Metadata Purging This endpoint deletes permanently the metadata schemas only. However, it does not purge the metadata from associated entities, so the metadata added to those entities will remain. If you want to purge metadata from the entities: 1. Remove all the definitions you want to purge. You can do this either in Voucherify Project Settings &gt; Metadata Schema tab or with the Update Metadata Schema endpoint. 2. In Voucherify Project Settings &gt; Metadata Schema tab, go to the relevant metadata schema. 3. In Removed definitions, click the bin button next to the definitions whose metadata you want to purge from entities. Note: - This is an asynchronous action. You will be notified when it has been completed. - You cannot purge metadata for the Redemption and Publication schemas. 4. Use the Delete Metadata Schema request to delete the metadata schema from Voucherify.  ðŸ“˜ Metadata Documentation  Read the Getting Started with Metadata articles to learn how metadata work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param metadata_schema_id [String] Provide the unique identifier of the metadata schema.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    private def delete_metadata_schema_with_http_info(project_id, metadata_schema_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.delete_metadata_schema ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/metadata-schemas/{metadataSchemaId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'metadataSchemaId' + '}', CGI.escape(metadata_schema_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.delete_metadata_schema",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#delete_metadata_schema\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Project
    # Deletes an existing project. The users currently using the deleted project will be automatically logged out.  ðŸš§ Sandbox Project The sandbox project cannot be deleted.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_project(project_id, opts = {})
      delete_project_with_http_info(project_id, opts)
      nil
    end

    # Delete Project
    # Deletes an existing project. The users currently using the deleted project will be automatically logged out.  ðŸš§ Sandbox Project The sandbox project cannot be deleted.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    private def delete_project_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.delete_project ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.delete_project",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#delete_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Stacking Rules
    # Deletes permanently the current settings for the stacking rules. The stacking rules are restored to default values.  ðŸ“˜ Stacking Rules Documentation  Read [the Stacking Rules article](https://support.voucherify.io/article/604-stacking-rules) to learn how they work.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param stacking_rules_id [String] Provide the unique identifier of the stacking rules.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_stacking_rules(project_id, stacking_rules_id, opts = {})
      delete_stacking_rules_with_http_info(project_id, stacking_rules_id, opts)
      nil
    end

    # Delete Stacking Rules
    # Deletes permanently the current settings for the stacking rules. The stacking rules are restored to default values.  ðŸ“˜ Stacking Rules Documentation  Read [the Stacking Rules article](https://support.voucherify.io/article/604-stacking-rules) to learn how they work.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param stacking_rules_id [String] Provide the unique identifier of the stacking rules.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    private def delete_stacking_rules_with_http_info(project_id, stacking_rules_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.delete_stacking_rules ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/stacking-rules/{stackingRulesId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'stackingRulesId' + '}', CGI.escape(stacking_rules_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.delete_stacking_rules",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#delete_stacking_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete Webhook
    # Deletes a webhook configuration.  ðŸ“˜ Webhook Documentation  Read Webhooks v2024-01-1 article to learn how webhooks work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param webhook_id [String] Provide the unique identifier of the webhook configuration.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_webhook(project_id, webhook_id, opts = {})
      delete_webhook_with_http_info(project_id, webhook_id, opts)
      nil
    end

    # Delete Webhook
    # Deletes a webhook configuration.  ðŸ“˜ Webhook Documentation  Read Webhooks v2024-01-1 article to learn how webhooks work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param webhook_id [String] Provide the unique identifier of the webhook configuration.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    private def delete_webhook_with_http_info(project_id, webhook_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.delete_webhook ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/webhooks/{webhookId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'webhookId' + '}', CGI.escape(webhook_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.delete_webhook",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#delete_webhook\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Brand
    # Retrieves a brand configuration.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param branding_id [String] Provide the unique identifier of the brand configuration.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsBrandingGetResponseBody]
    def get_brand(project_id, branding_id, opts = {})
      data, _status_code, _headers = get_brand_with_http_info(project_id, branding_id, opts)
      data
    end

    # Get Brand
    # Retrieves a brand configuration.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param branding_id [String] Provide the unique identifier of the brand configuration.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsBrandingGetResponseBody, Integer, Hash)>] ManagementProjectsBrandingGetResponseBody data, response status code and response headers
    private def get_brand_with_http_info(project_id, branding_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.get_brand ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/branding/{brandingId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'brandingId' + '}', CGI.escape(branding_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsBrandingGetResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.get_brand",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#get_brand\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Custom Event Schema
    # Retrieves a custom event schema.  ðŸ“˜ Custom Event Documentation  Read [Custom Events](https://support.voucherify.io/article/111-custom-events) article to learn how custom events work in Voucherify. Read also the details about the Track Custom Event endpoint and the Custom Event Object.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param custom_event_schema_id [String] Provide the unique identifier of the custom event schema.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsCustomEventSchemasGetResponseBody]
    def get_custom_event_schema(project_id, custom_event_schema_id, opts = {})
      data, _status_code, _headers = get_custom_event_schema_with_http_info(project_id, custom_event_schema_id, opts)
      data
    end

    # Get Custom Event Schema
    # Retrieves a custom event schema.  ðŸ“˜ Custom Event Documentation  Read [Custom Events](https://support.voucherify.io/article/111-custom-events) article to learn how custom events work in Voucherify. Read also the details about the Track Custom Event endpoint and the Custom Event Object.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param custom_event_schema_id [String] Provide the unique identifier of the custom event schema.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsCustomEventSchemasGetResponseBody, Integer, Hash)>] ManagementProjectsCustomEventSchemasGetResponseBody data, response status code and response headers
    private def get_custom_event_schema_with_http_info(project_id, custom_event_schema_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.get_custom_event_schema ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/custom-event-schemas/{customEventSchemaId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'customEventSchemaId' + '}', CGI.escape(custom_event_schema_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsCustomEventSchemasGetResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.get_custom_event_schema",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#get_custom_event_schema\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Metadata Schema
    # Retrieves a metadata schema.  ðŸ“˜ Metadata Documentation  Read the Getting Started with Metadata articles to learn how metadata work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param metadata_schema_id [String] Provide the unique identifier of the metadata schema.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsMetadataSchemasGetResponseBody]
    def get_metadata_schema1(project_id, metadata_schema_id, opts = {})
      data, _status_code, _headers = get_metadata_schema1_with_http_info(project_id, metadata_schema_id, opts)
      data
    end

    # Get Metadata Schema
    # Retrieves a metadata schema.  ðŸ“˜ Metadata Documentation  Read the Getting Started with Metadata articles to learn how metadata work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param metadata_schema_id [String] Provide the unique identifier of the metadata schema.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsMetadataSchemasGetResponseBody, Integer, Hash)>] ManagementProjectsMetadataSchemasGetResponseBody data, response status code and response headers
    private def get_metadata_schema1_with_http_info(project_id, metadata_schema_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.get_metadata_schema1 ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/metadata-schemas/{metadataSchemaId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'metadataSchemaId' + '}', CGI.escape(metadata_schema_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsMetadataSchemasGetResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.get_metadata_schema1",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#get_metadata_schema1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Project
    # Retrieves an existing project.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsGetResponseBody]
    def get_project(project_id, opts = {})
      data, _status_code, _headers = get_project_with_http_info(project_id, opts)
      data
    end

    # Get Project
    # Retrieves an existing project.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsGetResponseBody, Integer, Hash)>] ManagementProjectsGetResponseBody data, response status code and response headers
    private def get_project_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.get_project ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsGetResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.get_project",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#get_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Stacking Rules
    # Retrieves the stacking rules for the project.  ðŸ“˜ Stacking Rules Documentation  Read [the Stacking Rules article](https://support.voucherify.io/article/604-stacking-rules) to learn how they work.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param stacking_rules_id [String] Provide the unique identifier of the stacking rules.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsStackingRulesGetResponseBody]
    def get_stacking_rules(project_id, stacking_rules_id, opts = {})
      data, _status_code, _headers = get_stacking_rules_with_http_info(project_id, stacking_rules_id, opts)
      data
    end

    # Get Stacking Rules
    # Retrieves the stacking rules for the project.  ðŸ“˜ Stacking Rules Documentation  Read [the Stacking Rules article](https://support.voucherify.io/article/604-stacking-rules) to learn how they work.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param stacking_rules_id [String] Provide the unique identifier of the stacking rules.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsStackingRulesGetResponseBody, Integer, Hash)>] ManagementProjectsStackingRulesGetResponseBody data, response status code and response headers
    private def get_stacking_rules_with_http_info(project_id, stacking_rules_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.get_stacking_rules ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/stacking-rules/{stackingRulesId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'stackingRulesId' + '}', CGI.escape(stacking_rules_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsStackingRulesGetResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.get_stacking_rules",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#get_stacking_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get User
    # Retrieves the project users details.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param user_id [String] Provide the unique identifier of the user. Alternatively, provide the users login.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsUsersGetUserResponseBody]
    def get_user(project_id, user_id, opts = {})
      data, _status_code, _headers = get_user_with_http_info(project_id, user_id, opts)
      data
    end

    # Get User
    # Retrieves the project users details.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param user_id [String] Provide the unique identifier of the user. Alternatively, provide the users login.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsUsersGetUserResponseBody, Integer, Hash)>] ManagementProjectsUsersGetUserResponseBody data, response status code and response headers
    private def get_user_with_http_info(project_id, user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.get_user ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/users/{userId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'userId' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsUsersGetUserResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.get_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#get_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Webhook
    # Retrieves a webhook configuration.  ðŸ“˜ Webhook Documentation  Read Webhooks v2024-01-1 article to learn how webhooks work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param webhook_id [String] Provide the unique identifier of the webhook configuration.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsWebhooksGetResponseBody]
    def get_webhook(project_id, webhook_id, opts = {})
      data, _status_code, _headers = get_webhook_with_http_info(project_id, webhook_id, opts)
      data
    end

    # Get Webhook
    # Retrieves a webhook configuration.  ðŸ“˜ Webhook Documentation  Read Webhooks v2024-01-1 article to learn how webhooks work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param webhook_id [String] Provide the unique identifier of the webhook configuration.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsWebhooksGetResponseBody, Integer, Hash)>] ManagementProjectsWebhooksGetResponseBody data, response status code and response headers
    private def get_webhook_with_http_info(project_id, webhook_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.get_webhook ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/webhooks/{webhookId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'webhookId' + '}', CGI.escape(webhook_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsWebhooksGetResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.get_webhook",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#get_webhook\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Invite a New User
    # Sends an invitation to an email address that has not been used yet as a Voucherify user login. You can specify the projects to which the invited user will be assigned and define their roles.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsUsersInviteCreateRequestBody] :management_projects_users_invite_create_request_body Defines the details of the invitation, the project, and roles to which the user will be assigned.
    # @return [nil]
    def invite_user(opts = {})
      invite_user_with_http_info(opts)
      nil
    end

    # Invite a New User
    # Sends an invitation to an email address that has not been used yet as a Voucherify user login. You can specify the projects to which the invited user will be assigned and define their roles.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsUsersInviteCreateRequestBody] :management_projects_users_invite_create_request_body Defines the details of the invitation, the project, and roles to which the user will be assigned.
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    private def invite_user_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.invite_user ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/users/invite'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_users_invite_create_request_body'])

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.invite_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#invite_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Brands
    # Lists all brand configurations. Because a project can have only one brand, it always returns a list with one item. This endpoint can be used to retrieve the brand configuration created with the Voucherify Dashboard and the ID.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsBrandingListResponseBody]
    def list_brands(project_id, opts = {})
      data, _status_code, _headers = list_brands_with_http_info(project_id, opts)
      data
    end

    # List Brands
    # Lists all brand configurations. Because a project can have only one brand, it always returns a list with one item. This endpoint can be used to retrieve the brand configuration created with the Voucherify Dashboard and the ID.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsBrandingListResponseBody, Integer, Hash)>] ManagementProjectsBrandingListResponseBody data, response status code and response headers
    private def list_brands_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.list_brands ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/branding'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsBrandingListResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.list_brands",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#list_brands\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Custom Event Schemas
    # Lists all custom event schemas available in the project.  ðŸ“˜ Custom Event Documentation  Read [Custom Events](https://support.voucherify.io/article/111-custom-events) article to learn how custom events work in Voucherify. Read also the details about the Track Custom Event endpoint and the Custom Event Object.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsCustomEventSchemasListResponseBody]
    def list_custom_event_schemas(project_id, opts = {})
      data, _status_code, _headers = list_custom_event_schemas_with_http_info(project_id, opts)
      data
    end

    # List Custom Event Schemas
    # Lists all custom event schemas available in the project.  ðŸ“˜ Custom Event Documentation  Read [Custom Events](https://support.voucherify.io/article/111-custom-events) article to learn how custom events work in Voucherify. Read also the details about the Track Custom Event endpoint and the Custom Event Object.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsCustomEventSchemasListResponseBody, Integer, Hash)>] ManagementProjectsCustomEventSchemasListResponseBody data, response status code and response headers
    private def list_custom_event_schemas_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.list_custom_event_schemas ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/custom-event-schemas'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsCustomEventSchemasListResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.list_custom_event_schemas",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#list_custom_event_schemas\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Metadata Schemas
    # Lists all metadata schemas available in the project.  ðŸ“˜ Metadata Documentation  Read the Getting Started with Metadata articles to learn how metadata work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsMetadataSchemasListResponseBody]
    def list_metadata_schemas1(project_id, opts = {})
      data, _status_code, _headers = list_metadata_schemas1_with_http_info(project_id, opts)
      data
    end

    # List Metadata Schemas
    # Lists all metadata schemas available in the project.  ðŸ“˜ Metadata Documentation  Read the Getting Started with Metadata articles to learn how metadata work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsMetadataSchemasListResponseBody, Integer, Hash)>] ManagementProjectsMetadataSchemasListResponseBody data, response status code and response headers
    private def list_metadata_schemas1_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.list_metadata_schemas1 ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/metadata-schemas'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsMetadataSchemasListResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.list_metadata_schemas1",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#list_metadata_schemas1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Projects
    # Lists all projects for the organization. The endpoint does not require any query parameters.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsListResponseBody]
    def list_projects(opts = {})
      data, _status_code, _headers = list_projects_with_http_info(opts)
      data
    end

    # List Projects
    # Lists all projects for the organization. The endpoint does not require any query parameters.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsListResponseBody, Integer, Hash)>] ManagementProjectsListResponseBody data, response status code and response headers
    private def list_projects_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.list_projects ...'
      end
      # resource path
      local_var_path = '/management/v1/projects'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsListResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.list_projects",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#list_projects\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Stacking Rules
    # Lists all stacking rules. Returns always a list with one item. This endpoint can be used to retrieve the default stacking rules. The default stacking rules do not have an ID that could be used with the Get Stacking Rules or Update Stacking Rules endpoints.  ðŸ“˜ Stacking Rules Documentation  Read [the Stacking Rules article](https://support.voucherify.io/article/604-stacking-rules) to learn how they work.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsStackingRulesListResponseBody]
    def list_stacking_rules(project_id, opts = {})
      data, _status_code, _headers = list_stacking_rules_with_http_info(project_id, opts)
      data
    end

    # List Stacking Rules
    # Lists all stacking rules. Returns always a list with one item. This endpoint can be used to retrieve the default stacking rules. The default stacking rules do not have an ID that could be used with the Get Stacking Rules or Update Stacking Rules endpoints.  ðŸ“˜ Stacking Rules Documentation  Read [the Stacking Rules article](https://support.voucherify.io/article/604-stacking-rules) to learn how they work.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsStackingRulesListResponseBody, Integer, Hash)>] ManagementProjectsStackingRulesListResponseBody data, response status code and response headers
    private def list_stacking_rules_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.list_stacking_rules ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/stacking-rules'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsStackingRulesListResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.list_stacking_rules",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#list_stacking_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Users
    # Lists all users assigned to the project.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsUsersListResponseBody]
    def list_users(project_id, opts = {})
      data, _status_code, _headers = list_users_with_http_info(project_id, opts)
      data
    end

    # List Users
    # Lists all users assigned to the project.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsUsersListResponseBody, Integer, Hash)>] ManagementProjectsUsersListResponseBody data, response status code and response headers
    private def list_users_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.list_users ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/users'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsUsersListResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.list_users",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#list_users\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Webhooks
    # Lists all webhook configurations for the project.  ðŸ“˜ Webhook Documentation  Read Webhooks v2024-01-1 article to learn how webhooks work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [ManagementProjectsWebhooksListResponseBody]
    def list_webhooks(project_id, opts = {})
      data, _status_code, _headers = list_webhooks_with_http_info(project_id, opts)
      data
    end

    # List Webhooks
    # Lists all webhook configurations for the project.  ðŸ“˜ Webhook Documentation  Read Webhooks v2024-01-1 article to learn how webhooks work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ManagementProjectsWebhooksListResponseBody, Integer, Hash)>] ManagementProjectsWebhooksListResponseBody data, response status code and response headers
    private def list_webhooks_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.list_webhooks ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/webhooks'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsWebhooksListResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.list_webhooks",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#list_webhooks\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Copy Campaign Template to a Project
    # Copies a campaign template to another project. The resources, like validation rules or products, will not be copied to the destination project yet. When the template is used to create a new campaign or add a new promotion tier, the resources will be created in the destination project.  ðŸ“˜ Campaign Templates â€“ Documentation Read the [Campaign Templates documentation](https://support.voucherify.io/article/620-campaign-templates) to learn more about this feature.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param campaign_template_id [String] Provide the unique identifier of the campaign template.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsTemplatesCampaignsCopyCreateRequestBody] :management_projects_templates_campaigns_copy_create_request_body Determines the details about the template in the destination project as well as the destination project itself.
    # @return [ManagementProjectsTemplatesCampaignsCopyCreateResponseBody]
    def management_copy_campaign_template(project_id, campaign_template_id, opts = {})
      data, _status_code, _headers = management_copy_campaign_template_with_http_info(project_id, campaign_template_id, opts)
      data
    end

    # Copy Campaign Template to a Project
    # Copies a campaign template to another project. The resources, like validation rules or products, will not be copied to the destination project yet. When the template is used to create a new campaign or add a new promotion tier, the resources will be created in the destination project.  ðŸ“˜ Campaign Templates â€“ Documentation Read the [Campaign Templates documentation](https://support.voucherify.io/article/620-campaign-templates) to learn more about this feature.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param campaign_template_id [String] Provide the unique identifier of the campaign template.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsTemplatesCampaignsCopyCreateRequestBody] :management_projects_templates_campaigns_copy_create_request_body Determines the details about the template in the destination project as well as the destination project itself.
    # @return [Array<(ManagementProjectsTemplatesCampaignsCopyCreateResponseBody, Integer, Hash)>] ManagementProjectsTemplatesCampaignsCopyCreateResponseBody data, response status code and response headers
    private def management_copy_campaign_template_with_http_info(project_id, campaign_template_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.management_copy_campaign_template ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/templates/campaigns/{campaignTemplateId}/copy'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'campaignTemplateId' + '}', CGI.escape(campaign_template_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_templates_campaigns_copy_create_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsTemplatesCampaignsCopyCreateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.management_copy_campaign_template",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#management_copy_campaign_template\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # List Campaign Templates
    # Lists all campaign templates available in the project.  ðŸ‘ List Campaign Templates  This endpoint works in the same way as the List Campaign Templates endpoint.  ðŸ“˜ Campaign Templates â€“ Documentation Read the [Campaign Templates documentation](https://support.voucherify.io/article/620-campaign-templates) to learn more about this feature.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items.
    # @option opts [String] :starting_after_id A cursor for pagination. It retrieves the campaign templates created after a template with the given ID.
    # @option opts [ParameterTemplatesList] :order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order.
    # @option opts [Boolean] :include_total If set to true, the response returns the number of all campaign templates, regardless of the applied filters or limits. Set to false by default.
    # @option opts [ParameterFiltersListTemplates] :filters Filters for listing templates.
    # @return [ManagementProjectsTemplatesCampaignsListResponseBody]
    def management_list_campaign_templates(project_id, opts = {})
      data, _status_code, _headers = management_list_campaign_templates_with_http_info(project_id, opts)
      data
    end

    # List Campaign Templates
    # Lists all campaign templates available in the project.  ðŸ‘ List Campaign Templates  This endpoint works in the same way as the List Campaign Templates endpoint.  ðŸ“˜ Campaign Templates â€“ Documentation Read the [Campaign Templates documentation](https://support.voucherify.io/article/620-campaign-templates) to learn more about this feature.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items.
    # @option opts [String] :starting_after_id A cursor for pagination. It retrieves the campaign templates created after a template with the given ID.
    # @option opts [ParameterTemplatesList] :order Sorts the results using one of the filtering options, where the dash - preceding a sorting option means sorting in a descending order.
    # @option opts [Boolean] :include_total If set to true, the response returns the number of all campaign templates, regardless of the applied filters or limits. Set to false by default.
    # @option opts [ParameterFiltersListTemplates] :filters Filters for listing templates.
    # @return [Array<(ManagementProjectsTemplatesCampaignsListResponseBody, Integer, Hash)>] ManagementProjectsTemplatesCampaignsListResponseBody data, response status code and response headers
    private def management_list_campaign_templates_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.management_list_campaign_templates ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/templates/campaigns'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'starting_after_id'] = opts[:'starting_after_id'] if !opts[:'starting_after_id'].nil?
      query_params[:'order'] = opts[:'order'] if !opts[:'order'].nil?
      query_params[:'include_total'] = opts[:'include_total'] if !opts[:'include_total'].nil?
      query_params[:'filters'] = opts[:'filters'] if !opts[:'filters'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsTemplatesCampaignsListResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.management_list_campaign_templates",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#management_list_campaign_templates\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Unassign User
    # Unassigns the user from the project. If the user is currently logged in, they are automatically logged out. If the user is assigned to only one project, they cannot be unassigned from that project.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param user_id [String] Provide the unique identifier of the user. Alternatively, provide the users login.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def unassign_user(project_id, user_id, opts = {})
      unassign_user_with_http_info(project_id, user_id, opts)
      nil
    end

    # Unassign User
    # Unassigns the user from the project. If the user is currently logged in, they are automatically logged out. If the user is assigned to only one project, they cannot be unassigned from that project.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param user_id [String] Provide the unique identifier of the user. Alternatively, provide the users login.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    private def unassign_user_with_http_info(project_id, user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.unassign_user ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/users/{userId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'userId' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.unassign_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#unassign_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Brand
    # Updates a brand configuration. Only the fields sent in the request will be updated. The fields omitted in the request will remain unchanged.  ðŸ“˜ White Labelling  The white labelling settings which can be found in Project Settings > Brand Details and which are available only for Enterprise clients as a separate service can be configured only in the user interface.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param branding_id [String] Provide the unique identifier of the brand configuration.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsBrandingUpdateRequestBody] :management_projects_branding_update_request_body Defines the brand configuration to be updated.
    # @return [ManagementProjectsBrandingUpdateResponseBody]
    def update_brand(project_id, branding_id, opts = {})
      data, _status_code, _headers = update_brand_with_http_info(project_id, branding_id, opts)
      data
    end

    # Update Brand
    # Updates a brand configuration. Only the fields sent in the request will be updated. The fields omitted in the request will remain unchanged.  ðŸ“˜ White Labelling  The white labelling settings which can be found in Project Settings &gt; Brand Details and which are available only for Enterprise clients as a separate service can be configured only in the user interface.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param branding_id [String] Provide the unique identifier of the brand configuration.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsBrandingUpdateRequestBody] :management_projects_branding_update_request_body Defines the brand configuration to be updated.
    # @return [Array<(ManagementProjectsBrandingUpdateResponseBody, Integer, Hash)>] ManagementProjectsBrandingUpdateResponseBody data, response status code and response headers
    private def update_brand_with_http_info(project_id, branding_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.update_brand ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/branding/{brandingId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'brandingId' + '}', CGI.escape(branding_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_branding_update_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsBrandingUpdateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.update_brand",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#update_brand\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Custom Event Schema
    # Updates a custom event schema. With this request, you can: - Add a non-existing property to a custom event schema. - Update an existing property. In the request, you can provide only those properties you want to add or update. Definitions omitted in the request remain unchanged.  ðŸ‘ Additional Notes - You can change the type of an existing property, e.g. from string to number. - You can remove a custom property with this endpoint by providing deleted: true in the request. However, you cannot permanently remove an event definition or its property with this endpoint.  ðŸ“˜ Custom Event Documentation  Read [Custom Events](https://support.voucherify.io/article/111-custom-events) article to learn how custom events work in Voucherify. Read also the details about the Track Custom Event endpoint and the Custom Event Object.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param custom_event_schema_id [String] Provide the unique identifier of the custom event schema.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsCustomEventSchemasUpdateRequestBody] :management_projects_custom_event_schemas_update_request_body Defines the custom event schema to be updated.
    # @return [ManagementProjectsCustomEventSchemasUpdateResponseBody]
    def update_custom_event_schema(project_id, custom_event_schema_id, opts = {})
      data, _status_code, _headers = update_custom_event_schema_with_http_info(project_id, custom_event_schema_id, opts)
      data
    end

    # Update Custom Event Schema
    # Updates a custom event schema. With this request, you can: - Add a non-existing property to a custom event schema. - Update an existing property. In the request, you can provide only those properties you want to add or update. Definitions omitted in the request remain unchanged.  ðŸ‘ Additional Notes - You can change the type of an existing property, e.g. from string to number. - You can remove a custom property with this endpoint by providing deleted: true in the request. However, you cannot permanently remove an event definition or its property with this endpoint.  ðŸ“˜ Custom Event Documentation  Read [Custom Events](https://support.voucherify.io/article/111-custom-events) article to learn how custom events work in Voucherify. Read also the details about the Track Custom Event endpoint and the Custom Event Object.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param custom_event_schema_id [String] Provide the unique identifier of the custom event schema.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsCustomEventSchemasUpdateRequestBody] :management_projects_custom_event_schemas_update_request_body Defines the custom event schema to be updated.
    # @return [Array<(ManagementProjectsCustomEventSchemasUpdateResponseBody, Integer, Hash)>] ManagementProjectsCustomEventSchemasUpdateResponseBody data, response status code and response headers
    private def update_custom_event_schema_with_http_info(project_id, custom_event_schema_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.update_custom_event_schema ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/custom-event-schemas/{customEventSchemaId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'customEventSchemaId' + '}', CGI.escape(custom_event_schema_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_custom_event_schemas_update_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsCustomEventSchemasUpdateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.update_custom_event_schema",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#update_custom_event_schema\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Metadata Schema
    # Updates a metadata schema. With this request, you can: - Add a non-existing attribute definition to the metadata schema. - Update an existing attribute definition by overwriting its current values. In the request, you can provide only those definitions you want to add or update. Definitions omitted in the request remain unchanged. However, if you want to update a definition, you will have to add all its current key-value pairs as well. Only the pairs sent in the request are saved for this definition. This means that the key-value pairs that are not sent in a request are restored to default values. For example, if your definition has an array with values and it is not sent in an update request, the array values will be deleted.  ðŸ‘ Additional Notes - You cannot change the type of an existing schema, e.g. from string to number. - You can remove a definition with this endpoint by providing deleted: true in the request. It will be moved to the Removed definitions section in the user interface. However, you cannot permanently remove a definition with this endpoint.  ðŸ“˜ Metadata Documentation  Read the Getting Started with Metadata articles to learn how metadata work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param metadata_schema_id [String] Provide the unique identifier of the metadata schema.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsMetadataSchemasUpdateRequestBody] :management_projects_metadata_schemas_update_request_body Defines the metadata schema to be updated.
    # @return [ManagementProjectsMetadataSchemasUpdateResponseBody]
    def update_metadata_schema(project_id, metadata_schema_id, opts = {})
      data, _status_code, _headers = update_metadata_schema_with_http_info(project_id, metadata_schema_id, opts)
      data
    end

    # Update Metadata Schema
    # Updates a metadata schema. With this request, you can: - Add a non-existing attribute definition to the metadata schema. - Update an existing attribute definition by overwriting its current values. In the request, you can provide only those definitions you want to add or update. Definitions omitted in the request remain unchanged. However, if you want to update a definition, you will have to add all its current key-value pairs as well. Only the pairs sent in the request are saved for this definition. This means that the key-value pairs that are not sent in a request are restored to default values. For example, if your definition has an array with values and it is not sent in an update request, the array values will be deleted.  ðŸ‘ Additional Notes - You cannot change the type of an existing schema, e.g. from string to number. - You can remove a definition with this endpoint by providing deleted: true in the request. It will be moved to the Removed definitions section in the user interface. However, you cannot permanently remove a definition with this endpoint.  ðŸ“˜ Metadata Documentation  Read the Getting Started with Metadata articles to learn how metadata work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param metadata_schema_id [String] Provide the unique identifier of the metadata schema.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsMetadataSchemasUpdateRequestBody] :management_projects_metadata_schemas_update_request_body Defines the metadata schema to be updated.
    # @return [Array<(ManagementProjectsMetadataSchemasUpdateResponseBody, Integer, Hash)>] ManagementProjectsMetadataSchemasUpdateResponseBody data, response status code and response headers
    private def update_metadata_schema_with_http_info(project_id, metadata_schema_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.update_metadata_schema ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/metadata-schemas/{metadataSchemaId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'metadataSchemaId' + '}', CGI.escape(metadata_schema_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_metadata_schemas_update_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsMetadataSchemasUpdateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.update_metadata_schema",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#update_metadata_schema\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Project
    # Updates an existing project. You can add or modify settings for timezone, currency, notifications, and other details. Only the fields sent in the request will be updated.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsUpdateRequestBody] :management_projects_update_request_body Define the project details to be updated.
    # @return [ManagementProjectsUpdateResponseBody]
    def update_project(project_id, opts = {})
      data, _status_code, _headers = update_project_with_http_info(project_id, opts)
      data
    end

    # Update Project
    # Updates an existing project. You can add or modify settings for timezone, currency, notifications, and other details. Only the fields sent in the request will be updated.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsUpdateRequestBody] :management_projects_update_request_body Define the project details to be updated.
    # @return [Array<(ManagementProjectsUpdateResponseBody, Integer, Hash)>] ManagementProjectsUpdateResponseBody data, response status code and response headers
    private def update_project_with_http_info(project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.update_project ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_update_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsUpdateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.update_project",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#update_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Stacking Rules
    # Updates the stacking rules. Only the provided fields will be updated. However, if you update an array, the content of the array is overwritten. This means that if you want to add new values to an array and retain existing ones, you need to provide both the existing and new values in the request.  ðŸ“˜ Stacking Rules Documentation  Read [the Stacking Rules article](https://support.voucherify.io/article/604-stacking-rules) to learn how they work.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param stacking_rules_id [String] Provide the unique identifier of the stacking rules.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsStackingRulesUpdateRequestBody] :management_projects_stacking_rules_update_request_body Defines the stacking rules to be updated.
    # @return [ManagementProjectsStackingRulesUpdateResponseBody]
    def update_stacking_rules(project_id, stacking_rules_id, opts = {})
      data, _status_code, _headers = update_stacking_rules_with_http_info(project_id, stacking_rules_id, opts)
      data
    end

    # Update Stacking Rules
    # Updates the stacking rules. Only the provided fields will be updated. However, if you update an array, the content of the array is overwritten. This means that if you want to add new values to an array and retain existing ones, you need to provide both the existing and new values in the request.  ðŸ“˜ Stacking Rules Documentation  Read [the Stacking Rules article](https://support.voucherify.io/article/604-stacking-rules) to learn how they work.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param stacking_rules_id [String] Provide the unique identifier of the stacking rules.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsStackingRulesUpdateRequestBody] :management_projects_stacking_rules_update_request_body Defines the stacking rules to be updated.
    # @return [Array<(ManagementProjectsStackingRulesUpdateResponseBody, Integer, Hash)>] ManagementProjectsStackingRulesUpdateResponseBody data, response status code and response headers
    private def update_stacking_rules_with_http_info(project_id, stacking_rules_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.update_stacking_rules ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/stacking-rules/{stackingRulesId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'stackingRulesId' + '}', CGI.escape(stacking_rules_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_stacking_rules_update_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsStackingRulesUpdateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.update_stacking_rules",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#update_stacking_rules\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update User
    # Updates the users role.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param user_id [String] Provide the unique identifier of the user. Alternatively, provide the users login.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsUsersUpdateRoleRequestBody] :management_projects_users_update_role_request_body Defines the users new role.
    # @return [ManagementProjectsUsersUpdateRoleResponseBody]
    def update_user(project_id, user_id, opts = {})
      data, _status_code, _headers = update_user_with_http_info(project_id, user_id, opts)
      data
    end

    # Update User
    # Updates the users role.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param user_id [String] Provide the unique identifier of the user. Alternatively, provide the users login.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsUsersUpdateRoleRequestBody] :management_projects_users_update_role_request_body Defines the users new role.
    # @return [Array<(ManagementProjectsUsersUpdateRoleResponseBody, Integer, Hash)>] ManagementProjectsUsersUpdateRoleResponseBody data, response status code and response headers
    private def update_user_with_http_info(project_id, user_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.update_user ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/users/{userId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'userId' + '}', CGI.escape(user_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_users_update_role_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsUsersUpdateRoleResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.update_user",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#update_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update Webhook
    # Updates a webhook configuration. The events listed in the request are overwritten. If you want to add more events, provide also the events that are already in the webhook configuration.  ðŸ“˜ Webhook Documentation  Read Webhooks v2024-01-1 article to learn how webhooks work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param webhook_id [String] Provide the unique identifier of the webhook configuration.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsWebhooksUpdateRequestBody] :management_projects_webhooks_update_request_body Defines the webhook configuration to be updated.
    # @return [ManagementProjectsWebhooksUpdateResponseBody]
    def update_webhook(project_id, webhook_id, opts = {})
      data, _status_code, _headers = update_webhook_with_http_info(project_id, webhook_id, opts)
      data
    end

    # Update Webhook
    # Updates a webhook configuration. The events listed in the request are overwritten. If you want to add more events, provide also the events that are already in the webhook configuration.  ðŸ“˜ Webhook Documentation  Read Webhooks v2024-01-1 article to learn how webhooks work in Voucherify.
    # @param project_id [String] Provide the unique identifier of the project.
    # @param webhook_id [String] Provide the unique identifier of the webhook configuration.
    # @param [Hash] opts the optional parameters
    # @option opts [ManagementProjectsWebhooksUpdateRequestBody] :management_projects_webhooks_update_request_body Defines the webhook configuration to be updated.
    # @return [Array<(ManagementProjectsWebhooksUpdateResponseBody, Integer, Hash)>] ManagementProjectsWebhooksUpdateResponseBody data, response status code and response headers
    private def update_webhook_with_http_info(project_id, webhook_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ManagementApi.update_webhook ...'
      end
      # resource path
      local_var_path = '/management/v1/projects/{projectId}/webhooks/{webhookId}'.sub('{' + 'projectId' + '}', CGI.escape(project_id.to_s)).sub('{' + 'webhookId' + '}', CGI.escape(webhook_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'management_projects_webhooks_update_request_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'ManagementProjectsWebhooksUpdateResponseBody'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['X-Management-Token', 'X-Management-Id']

      new_options = opts.merge(
        :operation => :"ManagementApi.update_webhook",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ManagementApi#update_webhook\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
